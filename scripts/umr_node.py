from penman.models.amr import model as pm
from preprocess import interpersonal, advcl, modality, translate_number


class UMRNode:
    def __init__(self, ud_node, umr_graph, role: str = "", already_added=False):
        """
        Initializes a UMRNode instance, which is automatically added to the UMRGraph upon initialization.

        Args:
            ud_node (Union[UDdapi Node, str]): The UD node, or a string if an explicit node is unavailable.
            umr_graph (UMRGraph): The UMRGraph instance that this node is a part of.
            role (str): The semantic role associated with this node within the graph (e.g., "actor").
            already_added (bool): Indicates if the node has already been added to the graph. Defaults to False.

        Attributes:
            ud_node (Union[UDNode, str]): The UD node associated with this UMRNode.
            umr_graph (UMRGraph): The UMRGraph instance the node belongs to.
            role (str): The role that this node represents in the graph.
            self.var_name (str): A unique variable name assigned to the node, generated by the UMRGraph.
            self.parent (Optional[UMRNode]): The parent UMRNode of this node; initialized as None and set during processing.
            self.already_added (bool): Tracks whether this node has been added to the graph to prevent duplicates.
            self.check_needed (bool): A flag indicating if further checks are required for this node; initialized as False.
            self.extra_level (bool): A flag indicating if the node is involved in an abstract roleset construction; initialized as False.
            self.entity (bool): A flag indicating if the node will have to be replaced since it is ane entity; initialized as False.
            self.replace (bool): A flag indicating if the node has to be replaced (for modals); initialized as False.
            self.replaced (bool): A flag indicating if the node (entity) has already been replaced; initialized as False.
            """
        self.ud_node = ud_node
        self.umr_graph = umr_graph
        self.role = role
        self.var_name = self.umr_graph.assign_variable_name(ud_node)
        self.parent = None
        self.already_added = already_added
        self.check_needed = False
        self.extra_level = False
        self.entity = False
        self.replace = False
        self.replaced = False
        self.umr_graph.nodes.append(self)
        self.lang = self.umr_graph.lang

    def __repr__(self):
        return (f"Node(token='{self.ud_node if not isinstance(self.ud_node, str) else self.ud_node}', "
                f"role='{self.role}', var_name='{self.var_name}', extra_level={self.extra_level}, "
                f"parent={self.parent.var_name if hasattr(self.parent, 'var_name') else self.parent}')")

    @classmethod
    def find_by_ud_node(cls, umr_graph, ud_node):
        """
        Retrieve the UMRNode instance based on the given ud_node.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance to search within.
            ud_node: The UD node to search for.

        Returns:
            UMRNode: The UMRNode instance with the matching ud_node, or None if not found.
        """
        for node in umr_graph.nodes:
            if node.ud_node == ud_node:
                return node
        return None

    @classmethod
    def find_by_var_name(cls, umr_graph, var_name):
        """
        Retrieve the UMRNode instance with the given variable name.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance containing nodes.
            var_name (str): The variable name to search for.

        Returns:
            UMRNode: The UMRNode instance with the matching var_name, or None if not found.
        """
        for node in umr_graph.nodes:
            if node.var_name == var_name:
                return node
        return None

    @classmethod
    def find_children_by_parent(cls, umr_graph, parent_node):
        """
        Retrieves all UMRNode instances whose parent is the given parent_node.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance containing the nodes.
            parent_node (UMRNode): The parent UMRNode whose children should be retrieved.

        Returns:
            list: A list of UMRNode instances whose parent is the given parent_node.
        """
        children = []
        for node in umr_graph.nodes:
            if node.parent == parent_node:
                children.append(node)
        return children

    @classmethod
    def reattach_dependents(cls, umr_graph, old_parent, new_parent, remove=False, relaxed=False):
        """
        Reassigns dependents of an old parent node to a new parent node within a UMR graph.
        If `remove` is set to `True`, it also updates self.triples to reflect the new parent.

        Args:
            umr_graph (UMRGraph): The graph containing the nodes and triples.
            old_parent (UMRNode): The node whose dependents are being reassigned.
            new_parent (UMRNode): The node to which the dependents will be reassigned.
            remove (bool, optional): If `True`, replaces occurrences of `old_parent` in self.triples
                                     with `new_parent`. Default is `False`.
            relaxed (bool, optional): If `True`, skips role restrictions. Default is `False`.
        """
        deps = UMRNode.find_children_by_parent(umr_graph, old_parent)
        if deps:
            for d in deps:
                # Check role restrictions only if relaxed is False
                if not relaxed and d.role not in ['actor', 'undergoer', 'quant']:
                    continue
                d.parent = new_parent
                if remove:
                    umr_graph.find_and_replace_in_triples(d.var_name, 2, new_parent.var_name, 0)
                    umr_graph.triples = [
                        (new_parent.var_name, tup[1], tup[2]) if tup[0] == old_parent.var_name and tup[1] != 'instance'
                        else tup
                        for tup in umr_graph.triples
                    ]

    def introduce_abstract_roleset(self, role_aka_concept):
        """
        Introduces an abstract roleset instance (e.g., "identity-91").

        Args:
            role_aka_concept (str): The concept name for the abstract roleset, e.g. "identity-91".

        Triples added:
            - An inverted ARG1 relation between the new roleset concept and the parent of this node.
            - An ARG2 relation linking the new roleset concept to this node.
            - An aspect "state" relation.
        """
        self.umr_graph.find_and_remove_from_triples(role_aka_concept, 1)
        concept = UMRNode(role_aka_concept, self.umr_graph, already_added=True)
        self.umr_graph.triples.extend([
            pm.invert((concept.var_name, 'ARG1', self.parent.var_name)),
            (concept.var_name, 'ARG2', self.var_name),
        ])
        concept.aspect('state')
        concept.modality()

        self.parent, self.parent.parent = concept, concept

        return concept

    def replace_with_abstract_roleset(self, role_aka_concept, replace_arg=None, overt=True):
        """
        Replaces a syntactic construction with a UMR abstract roleset in the graph, and updates the graph accordingly.

        Args:
            role_aka_concept (str): The concept name for the abstract roleset to be introduced (e.g., "identity-91").
            replace_arg (str, optional): The argument to replace. If not provided, the default is "ARG2".
            overt (bool, optional): A flag indicating whether the predication is explicit (relevant to copulas). Default is `True`.

        Updates:
            - The UMR graph is modified by introducing a new abstract roleset concept node.
            - Triple relations are updated or added, including the introduction of new "ARG1" and "ARG2" relations.
            - Non-core dependents (e.g., vocatives, adverbial modifiers) are reattached to the new abstract roleset.
            - If the subject is elided (e.g., in the absence of a subject argument), a new node may be introduced.
        """
        second_arg = 'ARG2' if not replace_arg else replace_arg
        concept = UMRNode(role_aka_concept, self.umr_graph, self.parent.role, already_added=True)  # added role, check in debug
        self.parent.extra_level = True
        concept.parent = self.parent.parent
        self.parent.parent = concept
        self.already_added = True
        if concept.parent:
            self.umr_graph.triples.append((concept.parent.var_name, concept.role, concept.var_name))

        if self.umr_graph.root_var == self.parent.var_name:
            self.umr_graph.root_var = concept.var_name

        nsubj = next((s for s in self.ud_node.parent.children if s.udeprel in ['nsubj', 'csubj']), None)
        if nsubj:
            if overt:
                nsubj_node = UMRNode.find_by_ud_node(self.umr_graph, nsubj)
                self.umr_graph.find_and_remove_from_triples(self.var_name, 2)
                concept.ud_node = self.ud_node
                concept.ud_node.deprel = self.ud_node.parent.deprel
            else:
                nsubj_node = self
                concept.ud_node = None
            nsubj_node.extra_level = True
            nsubj_node.parent = concept
        else:
            nsubj_node = None

        for i, tup in enumerate(self.umr_graph.triples):
            if tup[2] == self.parent.var_name:
                self.umr_graph.triples[i] = (tup[0], tup[1], concept.var_name)
            if nsubj and not nsubj_node.extra_level:
                self.umr_graph.find_and_remove_from_triples(nsubj_node.var_name, 2)

        if nsubj:
            if nsubj not in self.umr_graph.track_conj:
                check = [tup for tup in self.umr_graph.triples if tup[1] == 'actor']
                if check:
                    for tup in check:
                        if tup[2] == nsubj_node.var_name:
                            self.umr_graph.triples.remove(tup)
                self.umr_graph.triples.append((concept.var_name, 'ARG1', nsubj_node.var_name))
                nsubj_node.parent = concept
                if not nsubj_node.extra_level:
                    self.umr_graph.triples.append((concept.var_name, second_arg, self.parent.var_name))
                    self.parent.parent = concept
                else:
                    parent = UMRNode.find_by_ud_node(self.umr_graph, nsubj.parent)
                    check = [tup for tup in self.umr_graph.triples if tup[1] == 'undergoer']
                    if check:
                        for tup in check:
                            if tup[2] == parent.var_name:
                                self.umr_graph.triples.remove(tup)
                    self.umr_graph.triples.append((concept.var_name, second_arg, parent.var_name))
                    parent.parent = concept

            else:
                self.umr_graph.triples.append((concept.var_name, 'ARG1', self.umr_graph.track_conj[nsubj]))
                arg1 = UMRNode.find_by_var_name(self.umr_graph, self.umr_graph.track_conj[nsubj])
                self.umr_graph.find_and_remove_from_triples(self.umr_graph.track_conj[nsubj], 2)
                self.umr_graph.triples.append((concept.var_name, second_arg, self.parent.var_name))
                arg1.parent = concept
                self.parent.parent = concept

            nsubj_node.parent, nsubj_node.parent.var_name = concept, concept.var_name
            nsubj_node.role = 'ARG1'
            nsubj_node.already_added = True

        else:
            self.umr_graph.triples.append((concept.var_name, second_arg, self.parent.var_name))

        concept.aspect('state')
        concept.modality()

        # reattach dependents
        UMRNode.reattach_dependents(self.umr_graph, self.parent, concept, remove=True)

        # elided subjects to be restored
        rel_dep = [s for s in self.ud_node.siblings if s.deprel == 'acl:relcl']
        if overt and nsubj is None and not rel_dep:
            arg_type = 'person' if self.ud_node.feats['Person'] in ['1', '2'] else 'FILL'
            new_node = self.create_node(arg_type)
            self.umr_graph.triples.append((concept.var_name, 'ARG1', new_node.var_name))

        return concept

    def add_node(self,
                 role,
                 invert: bool = False,
                 def_parent=None):
        """
        Adds a new triple to the UMR graph, connecting the current node with a parent node and a specified role.

        Args:
            role (str): The role that the current node assumes in relation to its parent (e.g., "actor").
            invert (bool, optional): If True, inverts the order of the triple. Defaults to False.
            def_parent (str, optional): The default parent to use if no parent is assigned to the current node.
            If not provided, `self.parent.var_name` will be used if `self.parent` is not available. Defaults to None.
        """
        if not def_parent:
            if self.parent:
                parent = self.parent.var_name
            else:
                parent = None
        else:
            parent = def_parent

        if self.umr_graph.find_in_triples(self.var_name, 2) == -1:
            if not invert:
                self.umr_graph.triples.append((parent, role, self.var_name))
            else:
                self.umr_graph.triples.append(pm.invert((self.var_name, role, parent)))
            self.already_added = True

        elif self.extra_level:
            if not invert:
                self.umr_graph.triples.append((parent, role, self.parent.var_name))
            else:
                self.umr_graph.triples.append(pm.invert((self.parent.var_name, role, parent)))
                self.already_added = True

        else:
            pass # it should be already okay

    def ud_to_umr(self):
        """ Map UD information to UMR structures. """
        root_var = None

        if not self.already_added:

            if self.ud_node.deprel == 'root':
                self.add_node(self.role)
                if not self.umr_graph.root_var:
                    self.umr_graph.root_var = self.var_name

            ########## check by UPOS ##########
            if self.ud_node.upos == 'PRON':
                self.entity = True

            elif self.ud_node.upos == 'DET':
                self.determiners_initial()

            elif self.ud_node.upos == 'VERB':
                # elided subjects to be restored
                if not any(d.udeprel in {'nsubj', 'csubj'} for d in self.ud_node.children) and self.ud_node.deprel != 'xcomp':
                    if self.ud_node.feats['Voice'] != 'Pass' and self.ud_node.feats['VerbForm'] != 'Part':
                        arg_type = 'person' if self.ud_node.feats['Person'] in ['1', '2'] else 'FILL'
                        new_node = self.create_node(arg_type)
                        self.umr_graph.triples.append((self.var_name, 'actor', new_node.var_name))
                self.modality()
                self.aspect()
                self.mode()

            elif self.ud_node.upos == 'PROPN':
                self.entity = True

            elif self.ud_node.upos in ['ADJ', 'ADV'] and self.ud_node.feats['Degree']:
                if not [c for c in self.ud_node.children if c.deprel == 'cop']:
                    self.have_degree()

            ########## check by deprel ##########
            if self.ud_node.deprel == 'nummod':
                self.quantities()

            elif self.ud_node.deprel == 'conj':
                role = next((k for k, v in self.umr_graph.deprels.items() for item in v if item == self.ud_node.parent), None)
                root_var = self.coordination(role)

            elif self.ud_node.udeprel in ['csubj', 'ccomp']:
                self.clauses()

            elif self.ud_node.deprel == 'appos':
                _ = self.introduce_abstract_roleset(self.role)

            elif self.ud_node.deprel == 'cop':
                self.copulas()

            # copular constructions with no overt copula
            elif self.ud_node.deprel == 'nsubj' and self.ud_node.parent.upos != 'VERB' and not [s for s in self.ud_node.siblings if s.deprel == 'cop']:
                self.copulas(copula=False)

            elif self.ud_node.deprel == 'acl:relcl':
                rel_pron = next((d for d in self.ud_node.descendants if d.feats.get('PronType') == 'Rel'), None)
                if not rel_pron:
                    if self.ud_node.parent.feats.get('PronType') == 'Rel':
                        rel_pron = self.ud_node.parent
                    else:
                        rel_pron = next((d for d in self.ud_node.descendants if d.upos == 'ADV'), None)

                rel_pron_node = UMRNode.find_by_ud_node(self.umr_graph, rel_pron)

                self.relative_clauses(rel_pron_node)
                rel_pron_node.already_added = True

            elif self.ud_node.deprel == 'acl':
                self.acl_participles()

            elif self.ud_node.udeprel == 'advcl':
                self.adverbial_clauses()

            if not self.already_added:
                self.add_node(self.role)
                if (self.ud_node.upos == 'NOUN' and self.role != 'other') or (self.ud_node.upos == 'ADJ' and self.ud_node.udeprel in ['nsubj', 'obj', 'obl']):
                    self.get_number_person('number')

        self.umr_graph.root_var = root_var if root_var else self.umr_graph.root_var

    def create_node(self, category: str, role: str = "", replace: bool = False, reflex: bool = False):
        """
        Creates a new UMRNode based on the specified category and role. The node type is determined by the 'category' argument.

        Allowed 'category' values:
            - 'person': A node representing a person.
            - 'thing': A node representing a non-person entity.
            - 'FILL': Used when the node type cannot be automatically classified as 'person' or 'thing'.
            - 'type-NE': Specifies the type of Named Entity (NE).
            - 'name': Specifies the name of the NE itself.

        Args:
            category (str): The category/type of the node to create. Must be one of ['person', 'thing', 'FILL', 'type-NE', 'name'].
            role (str, optional): The role of the node in the sentence or graph. Default is an empty string.
            replace (bool, optional): If True, replace an existing node in the graph. This is typically used for cases like replacing personal pronouns. 
                                      Default is False, which adds the new node without replacing any existing nodes.
            reflex (bool, optional): If True, the node is treated as a reflexive entity, typically used to determine whether the number (singular/plural) 
                                      should be handled differently. Default is False.

        Returns:
            UMRNode: The newly created UMRNode instance.
        """
        new_node = UMRNode(category, self.umr_graph, role=role, already_added=True)

        if replace:
            triples = self.umr_graph.find_and_remove_from_triples(self.var_name, 0, return_value=True)
            for t in triples:
                if t[1] and (t[1].endswith('-of') or t[1] != 'instance'):
                    self.umr_graph.triples.append(t)
            self.umr_graph.find_and_replace_in_triples(self.var_name, 2, new_node.var_name, 2)
            self.umr_graph.find_and_replace_in_triples(self.var_name, 0, new_node.var_name, 0)

        if category == 'person':
            self.get_number_person('person', new_node.var_name)

        if not reflex and category not in ['type-NE', 'name', 'more', 'most']:
            self.get_number_person('number', new_node.var_name)

        return new_node

    def get_number_person(self,
                          feature: str,
                          new_var_name: str = None,
                          given_feat: str = None):
        """ Extract refer-number and refer-person attributes. """

        feats = {
            **{k: '3rd' for k in ['3', 'ille', 'hic', 'is', 'ipse']},
            'Sing': 'singular',
            'Plur': 'plural',
            '1': '1st',
            '2': '2nd',
        }

        var_name = new_var_name if new_var_name else self.var_name
        if not given_feat:
            feat = feats.get(
                self.ud_node.feats.get(f"{feature.capitalize()}[psor]") or self.ud_node.feats.get(feature.capitalize()) or self.ud_node.lemma,
                'FILL')
        else:
            feat = given_feat

        self.umr_graph.triples.append((var_name, f'refer-{feature}', feat))

    def aspect(self, value=None):
        """ Assign aspect attribute. """

        already = [tup for tup in self.umr_graph.triples if tup[0] == self.var_name and tup[1] == 'aspect']
        if not already:

            if not value:
                if self.ud_node.feats['Aspect'] == 'Perf':
                    value = 'performance'
                else:
                    value = 'ASP'

            self.umr_graph.triples.append((self.var_name, 'aspect', value))

    def is_negative(self):
        """ Checks if the predicate qualifies for negative modal-strength based on syntactic elements like negation. """

        if hasattr(self.ud_node, 'children'):
            negation = [c for c in self.ud_node.children if c.deprel == 'advmod:neg']
            neg_element = [c for c in self.ud_node.children if c.feats['Polarity'] == 'Neg']
            return 'negative' if negation or neg_element else 'affirmative'

    def modality(self):
        """
        Assign modal-strength attribute.
        If a file with modality values for specific verbs is provided, it is used here to assign modal-strength and
        modal-predicate.
        """

        already = [tup for tup in self.umr_graph.triples if tup[0] == self.var_name and tup[1] in ['modal-strength', 'modal-predicate']]
        value = None

        # if modal-strength / modal-predicate have not been assigned yet
        if not already:

            if hasattr(self.ud_node, 'lemma'):
                if [el for el in modality["lexical"] if el["lemma"] == self.ud_node.lemma and el["replace"] == "yes"]:
                    self.umr_graph.find_and_remove_from_triples(self.var_name, 0)
                    self.already_added = True
                    return

            if self.parent and hasattr(self.parent.ud_node, 'lemma') and hasattr(self.ud_node, 'deprel') and self.ud_node.deprel in ['ccomp', 'xcomp']:
                # first, checking external file for modality - lexical check based on lemma.
                modpred = next(
                    (el["modal-predicate"] for el in modality["lexical"]
                     if el["lemma"] == self.parent.ud_node.lemma
                     and (el["constraint"] is None or eval(el["constraint"]))),
                    None
                )

                if modpred:
                    self.umr_graph.triples.append((self.var_name, 'modal-predicate', self.parent.var_name))
                    return

                else:
                    value_temp, replace = next(
                        ((el["modal-strength"], el["replace"]) for el in modality["lexical"]
                         if el["lemma"] == self.parent.ud_node.lemma
                         and (el["constraint"] is None or eval(el["constraint"]))),
                        (None, None)
                    )
                    value = f'{value_temp}-{self.is_negative()}'

                    if value and replace == 'yes':
                        self.parent.replace = True
                        for i, tup in enumerate(self.umr_graph.triples):
                            if tup[0] == self.var_name and tup[1] in ['aspect', 'modal-strength']:
                                del self.umr_graph.triples[i]
                        value = f"{value.split('-')[0]}-{self.parent.is_negative()}"
                        if self.parent.role == 'root' and self.parent.var_name == self.umr_graph.root_var:
                            self.umr_graph.root_var = self.var_name
                            UMRNode.reattach_dependents(self.umr_graph, self.parent, self, remove=True, relaxed=True)
                            self.parent = None
                            self.add_node('root')
                        else:
                            self.add_node(self.parent.role, def_parent=self.parent.parent)
                            UMRNode.reattach_dependents(self.umr_graph, self.parent, self, remove=True)

            # then, checking external file for modality - grammatical check based on construction.
            if not value and hasattr(self.ud_node, 'upos'):
                for el in modality["grammatical"]:
                    feats_from_el = el['node.feats'].split('|')
                    if el["node.upos"] == self.ud_node.upos and eval(el["constraint_on_children"]):
                        if all(feat in str(self.ud_node.feats).split('|') for feat in feats_from_el):
                            value = f'{el["modal-strength"]}-{self.is_negative()}'

            # if no value has been retrieved, check verbal features.
            if not value:
                if hasattr(self.ud_node, 'feats') and self.ud_node.feats['Mood'] == 'Ind' and self.ud_node.parent.is_root():
                    value = f'full-{self.is_negative()}'
                elif hasattr(self.ud_node, 'feats') and self.ud_node.feats['Mood'] == 'Imp':
                    value = f'partial-{self.is_negative()}'
                # otherwise, assign a placeholder for modal-strength.
                else:
                    value = 'MS'

            self.umr_graph.triples.append((self.var_name, 'modal-strength', value))

    def mode(self):
        """ Assign mode attribute. """
        value=None
        punct = [c for c in self.ud_node.children if c.upos == 'PUNCT']

        if self.ud_node.feats['Mood'] == 'Imp':
            value = 'imperative'
        elif punct:
            if any(item.lemma == '?' for item in punct):
                value = 'interrogative'

        if value:
            self.umr_graph.triples.append((self.var_name, 'mode', value))

        ####################### Language transformations #######################

    def determiners_initial(self):
        """
        Handles determiners in a literal way, i.e. without considering whether they should be replaced by a UMR entity.
        At a second stage, to avoid clashes with abstract concepts and coordination, they will be replaced by an entity annotation.
        """
        self.entity = True

        if self.ud_node.feats['PronType'] == 'Tot':
            role = self.role if self.role != 'det' else 'quant'
            cop_siblings = [s for s in self.ud_node.siblings if s.deprel == 'cop']
            has_cop_sibling = len(cop_siblings) > 0

            if self.ud_node.deprel == 'det' and not has_cop_sibling:
                self.add_node(role)
                self.entity = False
            else:
                role = self.role
                self.add_node(role)

        elif self.ud_node.upos == 'DET' and self.ud_node.feats['PronType'] == 'Prs':
            cop = [c for c in self.ud_node.children if c.deprel == 'cop']
            is_adj_noun = self.ud_node.parent.upos in ['ADJ', 'NOUN', 'PROPN'] or len(cop) > 0
            role = 'poss' if is_adj_noun else self.role
            self.add_node(role)

        else:
            role = self.role if self.role != 'det' else 'mod'
            self.add_node(role)

    def replace_entities(self):
        """
        Handles pronouns and determiners that are to be treated as entities in UMR graphs.
        """
        if self.entity:
            self.personal()
            self.possessives()
            self.quantifiers()
            self.det_pro_noun()
            self.named_entities()

    def personal(self):
        """ Handle pronouns - with a special focus on personal and indefinite. """

        if self.ud_node.upos in ['PRON', 'DET'] and not self.replaced and self.ud_node.deprel != 'det':

            category = 'thing' if self.ud_node.feats['Gender'] == 'Neut' else 'person' if self.ud_node.feats['PronType'] == 'Prs' else 'FILL'
            entity = self.create_node(category, self.role, replace=True)
            entity.ud_node = self.ud_node
            entity.parent = self.parent
            self.replaced = True

            if entity.ud_node.feats['PronType'] != 'Rel':

                if entity.ud_node.feats['PronType'] == 'Ind':
                    if not entity.ud_node.feats['Polarity'] == 'Neg':
                        self.umr_graph.triples.append((self.var_name, 'instance', self.ud_node.lemma))
                        self.add_node('mod', def_parent=entity.var_name)

            self.ud_node = None

            # reattach dependents
            UMRNode.reattach_dependents(self.umr_graph, self, entity, remove=True)

    def possessives(self):
        """
        Handle possessive constructions expressed with possessive adjectives.
        General possession should be encoded by the deprel nmod:poss (not treated here).
        """

        numbers = {'Sing': 'singular', 'Plur': 'plural'}

        if not self.replaced:
            if self.ud_node.upos == 'DET' and self.ud_node.feats['PronType'] == 'Prs':

                cop = [c for c in self.ud_node.children if c.deprel == 'cop']
                is_adj_noun = self.ud_node.parent.upos in ['ADJ', 'NOUN', 'PROPN'] or len(cop) > 0
                is_reflexive = self.ud_node.lemma == 'suus'

                category = 'person' if is_adj_noun else ('thing' if self.ud_node.parent.upos == 'VERB' and self.ud_node.feats['Gender'] == 'Neut' else 'FILL')
                role = 'poss' if is_adj_noun else self.role

                if is_adj_noun:
                    poss = self.create_node(category, role=role, replace=True, reflex=is_reflexive)
                    poss.ud_node = self.ud_node
                    poss.parent = self.parent
                    if is_reflexive:
                        refer_number = numbers.get(
                            self.ud_node.feats['Number'] if not is_adj_noun else self.ud_node.parent.parent.feats[
                                'Number'])
                        if refer_number:
                            poss.get_number_person('number', given_feat=refer_number)

                else:
                    entity = self.create_node(category, role=role, replace=True, reflex=is_reflexive)
                    entity.parent = self.parent
                    entity.ud_node = self.ud_node
                    poss = self.create_node('person', role=self.role, reflex=is_reflexive)
                    poss.parent = self.parent
                    self.umr_graph.find_and_replace_in_triples(self.var_name, 2, poss.var_name, 2)
                    self.umr_graph.triples.append((entity.var_name, 'poss', poss.var_name))

                    if is_reflexive:
                        refer_number = numbers.get(self.ud_node.parent.feats['Number'])
                        if refer_number:
                            poss.get_number_person('number', new_var_name=poss.var_name, given_feat=refer_number)

                self.replaced = True

    def quantifiers(self):
        """ Handle quantifiers. """

        if not self.replaced:
            if self.ud_node.feats['PronType'] == 'Tot':

                cop_siblings = [s for s in self.ud_node.siblings if s.deprel == 'cop']

                if self.ud_node.deprel != 'det' or (self.ud_node.deprel == 'det' and len(cop_siblings) == 1):
                    self.already_added = True
                    new_node = self.create_node('thing' if self.ud_node.feats['Gender'] == 'Neut' else 'FILL')
                    self.umr_graph.find_and_replace_in_triples(self.var_name, 2, new_node.var_name, 2)
                    self.parent = new_node

                    # attaching the quantifier itself
                    self.add_node('quant', def_parent=new_node.var_name)
                    self.replaced = True

    def det_pro_noun(self):
        """ Create an entity node that replaces the DETs (e.g. 'Illi negarunt' "They denied"). """

        if not self.replaced:
            if self.ud_node.deprel != 'det' and self.ud_node.feats['PronType'] == 'Dem':

                category = 'thing' if self.ud_node.feats['Gender'] == 'Neut' else 'person'  # maybe FILL is better
                new_node = self.create_node(category, role=self.role, replace=True)
                new_node.ud_node = self.ud_node
                new_node.parent = self.parent
                new_node.extra_level = self.extra_level
                self.already_added = True
                self.replaced = True

                # reattach dependents
                UMRNode.reattach_dependents(self.umr_graph, self, new_node, remove=True)

    def named_entities(self):
        """
        Processes proper nouns (PROPNs) and represents them as Named Entities (NE) following the conventions of the UMR
        framework. The entity type is not specified; `type-NE` is a placeholder that will have to be replaced by the
        annotator.
        """
        if not self.replaced:
            if self.ud_node.upos == 'PROPN' and self.role != 'other':

                entity = self.create_node('type-NE', self.role, replace=True)
                entity.ud_node = self.ud_node
                entity.parent = self.parent
                entity.extra_level = self.extra_level
                self.already_added, self.replaced = True, True

                name = self.create_node('name', 'name')
                name.add_node(name.role, def_parent=entity.var_name)

                names = [c for c in self.ud_node.children if c.deprel == 'flat:name' and c.upos == 'PROPN']
                names = [self] + [UMRNode.find_by_ud_node(self.umr_graph, n) for n in names]

                for i, n in enumerate(names, start=1):
                    self.umr_graph.triples.append((name.var_name, f'op{i}', f'"{n.ud_node.lemma}"'))
                    n.already_added, n.replaced = True, True

                # reattach dependents
                UMRNode.reattach_dependents(self.umr_graph, self, entity, remove=True)

    def coordination(self, role):
        """ Handle coordination by building the corresponding UMR structures. """

        conjs = {'or': ['vel', 'uel', 'aut'],
                 'and': ['que', 'et', 'ac', 'atque', 'nec', 'neque', ','],
                 'but-91': ['sed', 'at']}

        root_var = None

        # create one top node for the conjunction governing the coordination
        if self.ud_node.parent not in self.umr_graph.track_conj:  # node.parent is the head conjunct
            # identify conjunction type (polysyndeton or asyndeton)
            cc = next((c for c in self.ud_node.children if c.deprel == 'cc'), None)
            if cc is None:
                cc = next((c for c in self.ud_node.children if c.deprel == 'punct' and c.lemma == ','), None)
            cord = next((k for k, v in conjs.items() if cc and cc.lemma in v), None)
            if not cord:  # coordination without conjunction/comma
                cord = 'and'
            if cc:
                self.umr_graph.find_and_remove_from_triples(cc.lemma, 2)

            conj = UMRNode(cord, self.umr_graph, already_added=True)
            conj.ud_node = cc
            arg_type = 'op' if cord != 'but-91' else 'ARG'

            if not self.extra_level:
                first_conj = self.parent
                second_conj = self
            else:
                first_conj = self.parent.parent if self.parent.parent else None
                second_conj = self.parent

            first_conj.parent, second_conj.parent = conj, conj

            parent_parent = UMRNode.find_by_ud_node(self.umr_graph, self.ud_node.parent.parent)
            if self.ud_node.parent.parent.is_root() or (parent_parent.replace and parent_parent.ud_node.parent.is_root()):
                root_var = conj.var_name
                parent = None
            else:
                parent = UMRNode.find_by_ud_node(self.umr_graph, self.ud_node.parent.parent)
                conj.parent = parent

            for tup in self.umr_graph.triples:  # avoid clashes of abstract concepts and coordination
                if tup[2] == first_conj.var_name:
                    role, parent = tup[1], tup[0]
                    break

            self.umr_graph.triples = [tup for tup in self.umr_graph.triples if not (tup[0] == parent and tup[1] == role and tup[2] == first_conj.var_name)]
            if conj.var_name != root_var:
                self.umr_graph.triples.append((parent, role, conj.var_name))
            self.umr_graph.track_conj[self.ud_node.parent] = conj.var_name

            for i, vc in enumerate([first_conj, second_conj], start=1):
                self.umr_graph.triples.append((conj.var_name, f'{arg_type}{i}', vc.var_name))
                vc.parent = conj

            if (self.ud_node.upos == 'NOUN' and role != 'other') or (self.ud_node.upos == 'ADJ' and self.ud_node.deprel in ['nsubj', 'obj', 'obl']):
                self.get_number_person('number')
                second_conj.already_added = True

            # attach additional conjuncts, if any
            for i, oc in enumerate((s for s in self.ud_node.siblings if s.deprel == 'conj'), start=3):
                oc_node = UMRNode.find_by_ud_node(self.umr_graph, oc)
                if not oc_node.already_added:
                    oc_node.role = f'op{i}'
                    oc_node.parent = conj
                    self.umr_graph.triples.append((conj.var_name, oc_node.role, oc_node.var_name))
                    oc_node.get_number_person('number')
                    oc_node.already_added = True

        return root_var

    def copulas(self, copula=True):
        """
        Handle copular constructions by assigning the correct abstract roleset to the various configurations.
        If a set of relational terms is provided, it is used here to assign 'have-rel-role-92'.
        """
        replace_arg = None

        if self.ud_node.parent.feats['Case'] in ['Nom', 'Acc'] or (
                self.ud_node.parent.upos in ['NOUN', 'ADJ', 'PROPN', 'PRON'] and not self.ud_node.parent.feats['Case']):

            if self.ud_node.parent.feats['Degree']:
                self.parent.have_degree()
                return None

            elif self.ud_node.parent.upos == 'ADJ' or (self.ud_node.parent.upos == 'DET' and self.ud_node.parent.feats[
                'PronType'] != 'Prs'):  # TODO: double-check DET (for 'tantus' it can be ok, but for 'hic' identity would be better...ma both Dem!!)
                concept = 'have-mod-91'
            elif self.ud_node.parent.upos == 'DET' and self.ud_node.parent.feats['PronType'] == 'Prs':
                concept = 'belong-91'
            elif self.ud_node.parent.upos in ['NOUN', 'PRON']:
                if self.ud_node.parent.upos == 'NOUN' and self.ud_node.parent.lemma in interpersonal:
                    concept = 'have-rel-role-92'
                    replace_arg = 'ARG3'
                else:
                    concept = 'identity-91'
            else:
                concept = 'MISSING'

        elif self.ud_node.parent.feats['NumType'] == 'Card':
            concept = 'have-quant-91'

        elif self.ud_node.parent.feats['Case'] == 'Dat':
            # double dative if ref_dative else dative of possession
            ref_dative = [s for s in self.ud_node.siblings if s.feats['Case'] == 'Dat' and s.deprel == 'obl:arg']
            concept = 'have-purpose-91' if ref_dative else 'belong-91'

        elif self.ud_node.parent.upos == 'VERB' and self.ud_node.parent.feats['VerbForm'] == 'Inf':
            concept = 'have-identity-91'

        elif self.ud_node.parent.upos in ['NOUN', 'PROPN'] and self.ud_node.parent.feats['Case'] == 'Gen':
            concept = 'belong-91'
        else:
            concept = 'MISSING'

        _ = self.replace_with_abstract_roleset(concept, replace_arg, overt=copula)
        self.already_added = True
        if copula:
            self.umr_graph.triples.remove((self.var_name, 'instance', self.ud_node.lemma))

    def relative_clauses(self, rel_pron_node):
        """
        Process relative clauses, by handling:
        1. relative pronoun (rel_pron);
        2. predicate (node);
        3. referent of the whole relative clause (referent).
        """
        referent = None

        if rel_pron_node.ud_node == self.ud_node.parent:
            referent = rel_pron_node.var_name
            if rel_pron_node.ud_node.deprel == 'root':  # can't do anything about root-of, but I can at least save a root
                self.umr_graph.triples.append((None, 'root', referent))
        elif rel_pron_node.ud_node.parent == self.ud_node:
            if not self.extra_level:
                referent = self.parent.var_name if self.parent else None
            else:
                referent = self.parent.parent.var_name if self.parent.parent else None
            if rel_pron_node.ud_node.udeprel in ['nsubj', 'obj', 'obl']:
                self.umr_graph.find_and_remove_from_triples(rel_pron_node.var_name, 2)

        self.add_node(rel_pron_node.role, invert=True, def_parent=referent)
        rel_pron_node.check_needed = True

        for i, tup in enumerate(self.umr_graph.triples):
            if tup[1] == 'root-of':  # issues with head of relative being the root
                # look for other dependants
                if 'nsubj' in [d.deprel for d in self.ud_node.children]:
                    self.umr_graph.triples[i] = (tup[0], 'undergoer-of', tup[2])
                elif 'obj' in [d.deprel for d in self.ud_node.children]:
                    self.umr_graph.triples[i] = (tup[0], 'actor-of', tup[2])

    def adverbial_clauses(self):
        """
        Handle adverbial clauses.
        If a dictionary with disambiguated SCONJs is provided, it is used here to assign more fine-grained relations.
        """
        role = 'ADVCL'
        sconj = next((c for c in self.ud_node.children if c.deprel == 'mark'), None)

        if sconj and sconj.lemma in advcl:
            constraint = advcl.get(sconj.lemma, {}).get('constraint')
            if constraint:
                valid = []
                for c in constraint:
                    if c:
                        feat, value = c.split('=')
                        valid.append(sconj.parent.feats[feat] == value)
                if all(valid):
                    role = advcl.get(sconj.lemma, {}).get('type')
            else:
                role = advcl.get(sconj.lemma, {}).get('type')

        if not self.extra_level:
            if not (hasattr(self.ud_node, 'lemma') and [el for el in modality["lexical"] if el["lemma"] == self.ud_node.lemma and el["replace"] == "yes"]):
                self.role = role
                self.add_node(self.role)
                self.aspect()
                self.modality()
            else:
                xcomp = [c for c in self.ud_node.children if c.deprel == 'xcomp']
                if xcomp:
                    self.role = role
                    xcomp = UMRNode.find_by_ud_node(self.umr_graph, xcomp[0])
                    xcomp.add_node(self.role, def_parent=self.parent.var_name)
                    self.already_added = True
                    xcomp.aspect()
                    xcomp.modality()
        else:
            if self.parent.role == 'other':
                self.umr_graph.find_and_replace_in_triples(self.parent.var_name, 2, role, 1)
                self.parent.role = role
            self.parent.add_node(role, def_parent=self.parent.parent.var_name)
            self.aspect()
            self.modality()

    def clauses(self):
        """
        Handle clausal subjects and complements (csubj and ccomp).
        """
        if self.ud_node.deprel == 'ccomp:reported':
            self.umr_graph.triples.append((self.var_name, 'quot', self.parent.var_name))

        self.add_node(self.role)

    def quantities(self):
        """ Handle quantities, which are attributes in UMRs. """

        number = self.ud_node.form
        components = [c for c in self.ud_node.children if c.deprel == 'flat' and c.upos == 'NUM']
        components = [UMRNode.find_by_ud_node(self.umr_graph, c) for c in components]
        if components:
            for c in components:
                number += f' {c.ud_node.form}'
                c.already_added = True

        digit = translate_number(number, self.lang)
        self.umr_graph.triples.append((self.parent.var_name, ':quant', digit))
        self.already_added = True

    def have_degree(self):
        """ Convert comparative/superlative constructions to the abstract roleset have-degree-91. """

        degree = self.ud_node.feats['Degree']

        head = self.ud_node.udeprel in ['root', 'advcl', 'ccomp', 'xcomp', 'csubj', 'acl', 'conj']
        rebuild = self.ud_node.udeprel in ['nsubj', 'obj', 'obl', 'vocative']
        modifier = self.ud_node.deprel == 'amod'
        adverb = self.ud_node.deprel == 'advmod'

        if degree == 'Cmp':
            umr_degree = 'more'
        elif degree in ['Sup', 'Abs']:
            umr_degree = 'most'
        else:
            umr_degree = None

        if umr_degree:
            if modifier:
                have_degree = self.introduce_abstract_roleset('have-degree-91')
                degree_node = self.create_node(umr_degree, 'ARG3')
                self.umr_graph.triples.append((have_degree.var_name, degree_node.role, degree_node.var_name))
                self.already_added = True

            elif adverb:
                concept = UMRNode('have-degree-91', self.umr_graph, already_added=True)
                degree_node = self.create_node(umr_degree, 'ARG3')
                self.add_node(self.role)
                self.umr_graph.triples.extend([
                    pm.invert((concept.var_name, 'ARG2', self.var_name)),
                    (concept.var_name, degree_node.role, degree_node.var_name),
                ])
                self.parent, self.parent.parent = concept, concept
                self.already_added = True
                concept.aspect('state')
                concept.modality()

            elif head:
                cop = [c for c in self.ud_node.children if c.deprel == 'cop']
                if cop:
                    cop_node = UMRNode.find_by_ud_node(self.umr_graph, cop[0])
                    have_degree = cop_node.replace_with_abstract_roleset('have-degree-91')
                    degree_node = self.create_node(umr_degree, 'ARG3')
                    self.umr_graph.triples.append((have_degree.var_name, degree_node.role, degree_node.var_name))
                    cop_node.already_added = True

            elif rebuild:
                # substantivized ADJs
                new_node = self.create_node('FILL', self.role)
                new_node.parent = self.parent
                new_node.add_node(new_node.role)
                self.parent = new_node
                have_degree = self.introduce_abstract_roleset('have-degree-91')
                degree_node = self.create_node(umr_degree, 'ARG3')
                self.umr_graph.triples.append((have_degree.var_name, degree_node.role, degree_node.var_name))
                self.already_added = True

            if any([modifier, adverb, head, rebuild]):
                cmp = [c for c in self.ud_node.children if c.deprel == 'obl:cmp']
                if cmp:
                    cmp_node = UMRNode.find_by_ud_node(self.umr_graph, cmp[0])
                    cmp_node.role = 'ARG4'
                    cmp_node.add_node(cmp_node.role)
                    if cmp_node.ud_node.upos in ['NOUN', 'ADJ']:
                        cmp_node.get_number_person('number')
                    elif cmp_node.ud_node.upos in ['PRON', 'DET'] and cmp_node.ud_node.deprel != 'det':
                        cmp_node.entity = True

    def acl_participles(self):
        """
        Handle attributive participles (with deprel 'acl') similarly to relative clauses.
        """
        if self.ud_node.feats['VerbForm'] == 'Part':
            role = 'actor' if self.ud_node.feats['Voice'] == 'Act' else 'undergoer'
            self.add_node(role, invert=True, def_parent=self.parent.var_name)