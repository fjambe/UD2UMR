from penman.models.amr import model as pm
from preprocess import interpersonal, advcl

class UMRNode:
    def __init__(self, ud_node, umr_graph, role: str = "", already_added=False):
        """
        Initializes a UMRNode instance, which is automatically added to the UMRGraph upon initialization.

        Args:
            ud_node (Union[UDdapi Node, str]): The UD node, or a string if an explicit node is unavailable.
            umr_graph (UMRGraph): The UMRGraph instance that this node is a part of.
            role (str): The semantic role associated with this node within the graph (e.g., "actor").
            already_added (bool): Indicates if the node has already been added to the graph. Defaults to False.

        Attributes:
            ud_node (Union[UDNode, str]): The UD node associated with this UMRNode.
            umr_graph (UMRGraph): The UMRGraph instance the node belongs to.
            role (str): The role that this node represents in the graph.
            self.var_name (str): A unique variable name assigned to the node, generated by the UMRGraph.
            self.parent (Optional[UMRNode]): The parent UMRNode of this node; initialized as None and set during processing.
            self.already_added (bool): Tracks whether this node has been added to the graph to prevent duplicates.
            self.check_needed (bool): A flag indicating if further checks are required for this node; initialized as False.
            self.extra_level (bool): A flag indicating if the node is involved in an abstract roleset construction; initialized as False.
            self.entity (bool): A flag indicating if the node will have to be replaced since it is ane entity; initialized as False.
            self.replaced (bool): A flag indicating if the node (entity) has already been replaced; initialized as False.
            """
        self.ud_node = ud_node
        self.umr_graph = umr_graph
        self.role = role
        self.var_name = self.umr_graph.assign_variable_name(ud_node)
        self.parent = None
        self.already_added = already_added
        self.check_needed = False
        self.extra_level = False
        self.entity = False
        self.replaced = False
        self.umr_graph.nodes.append(self)

    def __repr__(self):
        return (f"Node(token='{self.ud_node.form if not isinstance(self.ud_node, str) else self.ud_node}', "
                f"role='{self.role}', var_name='{self.var_name}', extra_level={self.extra_level}, "
                f"parent={self.parent.var_name if hasattr(self.parent, 'var_name') else self.parent}')")

    @classmethod
    def find_by_ud_node(cls, umr_graph, ud_node):
        """
        Retrieve the UMRNode instance based on the given ud_node.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance to search within.
            ud_node: The UD node to search for.

        Returns:
            UMRNode: The UMRNode instance with the matching ud_node, or None if not found.
        """
        for node in umr_graph.nodes:
            if node.ud_node == ud_node:
                return node
        return None

    @classmethod
    def find_by_var_name(cls, umr_graph, var_name):
        """
        Retrieve the UMRNode instance with the given variable name.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance containing nodes.
            var_name (str): The variable name to search for.

        Returns:
            UMRNode: The UMRNode instance with the matching var_name, or None if not found.
        """
        for node in umr_graph.nodes:
            if node.var_name == var_name:
                return node
        return None

    @classmethod
    def find_children_by_parent(cls, umr_graph, parent_node):
        """
        Retrieves all UMRNode instances whose parent is the given parent_node.

        Args:
            umr_graph (UMRGraph): The UMRGraph instance containing the nodes.
            parent_node (UMRNode): The parent UMRNode whose children should be retrieved.

        Returns:
            list: A list of UMRNode instances whose parent is the given parent_node.
        """
        children = []
        for node in umr_graph.nodes:
            if node.parent == parent_node:
                children.append(node)
        return children

    @classmethod
    def reattach_dependents(cls, umr_graph, old_parent, new_parent, remove=False):
        """
        Reassigns dependents of an old parent node to a new parent node within a UMR graph.
        If `remove` is set to `True`, it also updates self.triples to reflect the new parent.

        Args:
            umr_graph (UMRGraph): The graph containing the nodes and triples.
            old_parent (UMRNode): The node whose dependents are being reassigned.
            new_parent (UMRNode): The node to which the dependents will be reassigned.
            remove (bool, optional): If `True`, replaces occurrences of `old_parent` in self.triples
                                     with `new_parent`. Default is `False`.
        """
        deps = UMRNode.find_children_by_parent(umr_graph, old_parent)
        if deps:
            for d in deps:
                if d.role not in ['actor', 'patient']:
                    d.parent = new_parent
                    if remove:
                        umr_graph.find_and_replace_in_triples(d.var_name, 2, new_parent.var_name, 0)

    def introduce_abstract_roleset(self, role_aka_concept):
        """
        Introduces an abstract roleset instance (e.g., "identity-91").

        Args:
            role_aka_concept (str): The concept name for the abstract roleset, e.g. "identity-91".

        Triples added:
            - An inverted ARG1 relation between the new roleset concept and the parent of this node.
            - An ARG2 relation linking the new roleset concept to this node.
            - An aspect "state" relation.
        """
        # TODO: it should also work for reification in general, so it could be renamed. Decide later.
        # double check also that role inversion can be generalized.

        self.umr_graph.find_and_remove_from_triples(role_aka_concept, 1)
        concept = UMRNode(role_aka_concept, self.umr_graph, already_added=True)
        self.umr_graph.triples.extend([
            pm.invert((concept.var_name, 'ARG1', self.parent.var_name)),
            (concept.var_name, 'ARG2', self.var_name),
            (concept.var_name, 'aspect', 'state')
        ])

    def replace_with_abstract_roleset(self, role_aka_concept, replace_arg=None, overt=True):
        """
        Replaces a syntactic construction with a UMR abstract roleset in the graph, and updates the graph accordingly.

        Args:
            role_aka_concept (str): The concept name for the abstract roleset to be introduced (e.g., "identity-91").
            replace_arg (str, optional): The argument to replace. If not provided, the default is "ARG2".
            overt (bool, optional): A flag indicating whether the predication is explicit (relevant to copulas). Default is `True`.

        Updates:
            - The UMR graph is modified by introducing a new abstract roleset concept node.
            - Triple relations are updated or added, including the introduction of new "ARG1" and "ARG2" relations.
            - Non-core dependents (e.g., vocatives, adverbial modifiers) are reattached to the new abstract roleset.
            - If the subject is elided (e.g., in the absence of a subject argument), a new node may be introduced.
        """

        # TODO: Figure out whether it can be merged with introduce_abstract_roleset().

        second_arg = 'ARG2' if not replace_arg else replace_arg

        concept_node = UMRNode(role_aka_concept, self.umr_graph, already_added=True)
        self.parent.extra_level = True
        concept_node.parent = self.parent.parent
        self.parent.parent = concept_node

        if self.umr_graph.root_var == self.parent.var_name:
            self.umr_graph.root_var = concept_node.var_name

        nsubj = next((s for s in self.ud_node.parent.children if s.udeprel in ['nsubj', 'csubj']), None)
        if nsubj:
            if overt:
                nsubj_node = UMRNode.find_by_ud_node(self.umr_graph, nsubj)
                self.umr_graph.find_and_remove_from_triples(self.var_name, 2)
            else:
                nsubj_node = self
            nsubj_node.extra_level = True
            nsubj_node.parent = concept_node
        else:
            nsubj_node = None

        for i, tup in enumerate(self.umr_graph.triples):
            if tup[2] == self.parent.var_name:
                self.umr_graph.triples[i] = (tup[0], tup[1], concept_node.var_name)
            if nsubj and not nsubj_node.extra_level:
                self.umr_graph.find_and_remove_from_triples(nsubj_node.var_name, 2)

        if nsubj:
            if nsubj not in self.umr_graph.track_conj:
                check = [tup for tup in self.umr_graph.triples if tup[1] == 'actor']
                if check:
                    for tup in check:
                        if tup[2] == nsubj_node.var_name:
                            self.umr_graph.triples.remove(tup)
                self.umr_graph.triples.append((concept_node.var_name, 'ARG1', nsubj_node.var_name))
                if not nsubj_node.extra_level:
                    self.umr_graph.triples.append((concept_node.var_name, second_arg, self.parent.var_name))
                else:
                    parent = UMRNode.find_by_ud_node(self.umr_graph, nsubj.parent)
                    check = [tup for tup in self.umr_graph.triples if tup[1] == 'patient']
                    if check:
                        for tup in check:
                            if tup[2] == parent.var_name:
                                self.umr_graph.triples.remove(tup)
                    self.umr_graph.triples.append((concept_node.var_name, second_arg, parent.var_name))

            else:
                self.umr_graph.triples.append((concept_node.var_name, 'ARG1', self.umr_graph.track_conj[nsubj]))
                self.umr_graph.find_and_remove_from_triples(self.umr_graph.track_conj[nsubj], 2)
                self.umr_graph.triples.append((concept_node.var_name, second_arg, self.var_name))

            nsubj_node.parent, nsubj_node.parent.var_name = concept_node, concept_node.var_name
            nsubj_node.role = 'ARG1'
            nsubj_node.already_added = True

        self.umr_graph.triples.append((concept_node.var_name, 'aspect', 'state'))

        # reattach dependents
        UMRNode.reattach_dependents(self.umr_graph, self.parent, concept_node)

        # elided subjects to be restored
        rel_dep = [s for s in self.ud_node.siblings if s.deprel == 'acl:relcl']
        if overt and nsubj is None and not rel_dep:
            arg_type = 'person' if self.ud_node.feats['Person'] in ['1', '2'] else 'FILL'
            new_node = self.create_node(arg_type)
            self.umr_graph.triples.append((concept_node.var_name, 'ARG1', new_node.var_name))

    def add_node(self,
                 role,
                 invert: bool = False,
                 def_parent=None):
        """
        Adds a new triple to the UMR graph, connecting the current node with a parent node and a specified role.

        Args:
            role (str): The role that the current node assumes in relation to its parent (e.g., "actor").
            invert (bool, optional): If True, inverts the order of the triple. Defaults to False.
            def_parent (str, optional): The default parent to use if no parent is assigned to the current node.
            If not provided, `self.parent.var_name` will be used if `self.parent` is not available. Defaults to None.
        """
        if not def_parent:
            if self.parent:
                parent = self.parent.var_name
            else:
                parent = None
        else:
            parent = def_parent

        if self.umr_graph.find_in_triples(self.var_name, 2) == -1:
            if not invert:
                self.umr_graph.triples.append((parent, role, self.var_name))
            else:
                self.umr_graph.triples.append(pm.invert((self.var_name, role, parent)))
            self.already_added = True

        elif self.extra_level:
            if not invert:
                self.umr_graph.triples.append((parent, role, self.parent.var_name))
            else:
                self.umr_graph.triples.append(pm.invert((self.parent.var_name, role, parent)))
                self.already_added = True

        else:
            pass # it should be already okay

    def ud_to_umr(self):
        """ Map UD information to UMR structures. """
        root_var = None

        if not self.already_added:

            if self.ud_node.deprel == 'root':
                self.add_node(self.role)
                if not self.umr_graph.root_var:
                    self.umr_graph.root_var = self.var_name

            ########## check by UPOS ##########
            if self.ud_node.upos == 'PRON':
                self.entity = True
                # TODO: do something with non-personal pronouns, here.

            elif (self.ud_node.upos == 'NOUN' and self.role != 'other') or (
                    self.ud_node.upos == 'ADJ' and self.ud_node.deprel in ['nsubj', 'obj', 'obl']):  # TODO: might be merged with leftover add_role
                self.add_node(self.role)
                self.get_number_person('number')

            elif self.ud_node.upos == 'DET':
                self.determiners_initial()

            elif self.ud_node.upos == 'VERB':
                # elided subjects to be restored
                if 'nsubj' not in [d.udeprel for d in
                                   self.ud_node.children] and self.ud_node.parent.deprel != 'root':  # root check is a bit random
                    if self.ud_node.feats['Voice'] != 'Pass':
                        arg_type = 'person' if self.ud_node.feats['Person'] in ['1', '2'] else 'FILL'
                        new_node = self.create_node(arg_type)
                        self.umr_graph.triples.append((self.var_name, 'actor', new_node.var_name))

            ########## check by deprel ##########
            if self.ud_node.deprel == 'conj':
                role = next((k for k, v in self.umr_graph.deprels.items() for item in v if item == self.ud_node.parent), None)
                root_var = self.coordination(role)
            elif self.ud_node.deprel == 'appos':
                self.introduce_abstract_roleset(self.role)

            elif self.ud_node.deprel == 'cop':
                self.copulas()

            # copular constructions with no overt copula
            elif self.ud_node.deprel == 'nsubj' and self.ud_node.parent.upos != 'VERB' and not [s for s in self.ud_node.siblings if s.deprel == 'cop']:
                self.copulas(copula=False)

            elif self.ud_node.deprel == 'acl:relcl':
                rel_pron = next((d for d in self.ud_node.descendants if d.feats.get('PronType') == 'Rel'), None)
                if not rel_pron:
                    if self.ud_node.parent.feats.get('PronType') == 'Rel':
                        rel_pron = self.ud_node.parent
                    else:
                        rel_pron = next((d for d in self.ud_node.descendants if d.upos == 'ADV'), None)

                rel_pron_node = UMRNode.find_by_ud_node(self.umr_graph, rel_pron)

                self.relative_clauses(rel_pron_node)
                rel_pron_node.already_added = True

            elif self.ud_node.deprel == 'advcl':
                self.adverbial_clauses()

            if not self.already_added:
                self.add_node(self.role)

        self.umr_graph.root_var = root_var if root_var else self.umr_graph.root_var

    ####################### Language transformations #######################

    def create_node(self, category: str, role: str = "", replace: bool = False, reflex: bool = False):
        """
        Creates a new UMRNode based on the specified category and role. The node type is determined by the 'category' argument.

        Allowed 'category' values:
            - 'person': A node representing a person.
            - 'thing': A node representing a non-person entity.
            - 'FILL': Used when the node type cannot be automatically classified as 'person' or 'thing'.

        Args:
            category (str): The category/type of the node to create. Must be one of ['person', 'thing', 'FILL'].
            role (str, optional): The role of the node in the sentence or graph. Default is an empty string.
            replace (bool, optional): If True, replace an existing node in the graph. This is typically used for cases like replacing personal pronouns. 
                                      Default is False, which adds the new node without replacing any existing nodes.
            reflex (bool, optional): If True, the node is treated as a reflexive entity, typically used to determine whether the number (singular/plural) 
                                      should be handled differently. Default is False.

        Returns:
            UMRNode: The newly created UMRNode instance.
        """
        new_node = UMRNode(category, self.umr_graph, role=role, already_added=True)

        if replace:
            self.umr_graph.find_and_remove_from_triples(self.var_name, 0)
            self.umr_graph.find_and_replace_in_triples(self.var_name, 2, new_node.var_name, 2)

        if category == 'person':
            self.get_number_person('person', new_node.var_name)

        if not reflex:
            self.get_number_person('number', new_node.var_name)

        return new_node

    def get_number_person(self,
                          feature: str,
                          new_var_name: str = None,
                          given_feat: str = None):
        """ Extract refer-number and refer-person attributes. """

        feats = {
            **{k: '3rd' for k in ['3', 'ille', 'hic', 'is', 'ipse']},
            'Sing': 'singular',
            'Plur': 'plural',
            '1': '1st',
            '2': '2nd',
        }

        var_name = new_var_name if new_var_name else self.var_name
        if not given_feat:
            feat = feats.get(
                self.ud_node.feats.get(f"{feature.capitalize()}[psor]") or self.ud_node.feats.get(feature.capitalize()) or self.ud_node.lemma,
                'FILL')
        else:
            feat = given_feat

        self.umr_graph.triples.append((var_name, f'refer-{feature}', feat))

    def determiners_initial(self):
        """
        Handles determiners in a literal way, i.e. without considering whether they should be replaced by a UMR entity.
        At a second stage, to avoid clashes with abstract concepts and coordination, they will be replaced by an entity annotation.
        """
        self.entity = True

        if self.ud_node.feats['PronType'] == 'Tot':
            role = self.role if self.role != 'det' else 'quant'
            cop_siblings = [s for s in self.ud_node.siblings if s.deprel == 'cop']
            has_cop_sibling = len(cop_siblings) > 0

            if self.ud_node.deprel == 'det' and not has_cop_sibling:
                self.add_node(role)
                self.entity = False
            else:
                role = self.role
                self.add_node(role)

        elif self.ud_node.upos == 'DET' and self.ud_node.feats['PronType'] == 'Prs':
            cop = [c for c in self.ud_node.children if c.deprel == 'cop']
            is_adj_noun = self.ud_node.parent.upos in ['ADJ', 'NOUN', 'PROPN'] or len(cop) > 0
            role = 'poss' if is_adj_noun else self.role
            self.add_node(role)

        else:
            role = self.role
            self.add_node(role)

        if self.ud_node.deprel == 'det' and not self.already_added:
            self.add_node('mod')

    def replace_entities(self):
        """
        Handles pronouns and determiners that are to be treated as entities in UMR graphs.
        """
        if self.entity:
            self.personal()
            self.possessives()
            self.quantifiers()
            self.det_pro_noun()

    def personal(self):
        """ Handle personal pronouns. """

        # TODO: could probably be expanded to handle all pronouns.

        if self.ud_node.upos == 'PRON' and self.ud_node.feats['PronType'] == 'Prs':

            category = 'person' if self.ud_node.feats['Gender'] != 'Neut' else 'thing'
            pron = self.create_node(category, self.role, replace=True)
            pron.parent = self.parent
            self.replaced = True

            # reattach dependents
            UMRNode.reattach_dependents(self.umr_graph, self, pron, remove=True)

    def possessives(self):
        """
        Handle possessive constructions.
        1. Basic case: possessive adjectives
        2. Non-reflexive 3rd person (eius): TODO
        3. General possession: encoded by the deprel nmod:poss, not treated here. Otherwise undetectable, because lexical.
        """

        numbers = {'Sing': 'singular', 'Plur': 'plural'}

        if self.ud_node.upos == 'DET' and self.ud_node.feats['PronType'] == 'Prs' and not self.replaced:

            cop = [c for c in self.ud_node.children if c.deprel == 'cop']
            is_adj_noun = self.ud_node.parent.upos in ['ADJ', 'NOUN', 'PROPN'] or len(cop) > 0
            is_reflexive = self.ud_node.lemma == 'suus'

            category = 'person' if is_adj_noun else ('thing' if self.ud_node.parent.upos == 'VERB' and self.ud_node.feats['Gender'] == 'Neut' else 'FILL')
            role = 'poss' if is_adj_noun else self.role

            if is_adj_noun:
                poss = self.create_node(category, role=role, replace=True, reflex=is_reflexive)
                poss.parent = self.parent
                if is_reflexive:
                    refer_number = numbers.get(
                        self.ud_node.feats['Number'] if not is_adj_noun else self.ud_node.parent.parent.feats[
                            'Number'])
                    if refer_number:
                        poss.get_number_person('number', given_feat=refer_number)

            else:
                entity = self.create_node(category, role=role, replace=True, reflex=is_reflexive)
                entity.parent = self.parent
                poss = self.create_node('person', role=self.role, reflex=is_reflexive)
                poss.parent = self.parent
                self.umr_graph.find_and_replace_in_triples(self.var_name, 2, poss.var_name, 2)
                self.umr_graph.triples.append((entity.var_name, 'poss', poss.var_name))

                if is_reflexive:
                    refer_number = numbers.get(self.ud_node.parent.feats['Number'])
                    if refer_number:
                        poss.get_number_person('number', new_var_name=poss.var_name, given_feat=refer_number)

            self.replaced = True

    def quantifiers(self):
        """ Handle quantifiers. """

        if self.ud_node.feats['PronType'] == 'Tot':

            cop_siblings = [s for s in self.ud_node.siblings if s.deprel == 'cop']

            if self.ud_node.deprel != 'det' or (self.ud_node.deprel == 'det' and len(cop_siblings) == 1):
                self.already_added = True
                new_node = self.create_node('thing' if self.ud_node.feats['Gender'] == 'Neut' else 'FILL')
                self.umr_graph.find_and_replace_in_triples(self.var_name, 2, new_node.var_name, 2)
                self.parent = new_node

                # attaching the quantifier itself
                self.add_node('quant', def_parent=new_node.var_name)
                self.replaced = True

    def det_pro_noun(self):
        """ Create an entity node that replaces the DETs (e.g. 'Illi negarunt' "They denied"). """

        if self.ud_node.deprel != 'det' and self.ud_node.feats['PronType'] == 'Dem' and not self.replaced:

            category = 'thing' if self.ud_node.feats['Gender'] == 'Neut' else 'person'  # maybe FILL is better
            new_node = self.create_node(category, role=self.role, replace=True)

            new_node.parent = self.parent
            new_node.extra_level = self.extra_level
            self.already_added = True
            self.replaced = True

            # reattach dependents
            UMRNode.reattach_dependents(self.umr_graph, self, new_node, remove=True)

    def coordination(self, role):
        """ Handle coordination by building the corresponding UMR structures. """

        conjs = {'or': ['vel', 'uel', 'aut'],
                 'and': ['que', 'et', 'ac', 'atque', 'nec', 'neque', ','],
                 'but-91': ['sed', 'at']}

        root_var = None

        # create one top node for the conjunction governing the coordination
        if self.ud_node.parent not in self.umr_graph.track_conj:  # node.parent is the head conjunct
            # identify conjunction type (polysyndeton or asyndeton)
            cc = next((c for c in self.ud_node.children if c.deprel == 'cc'), None)
            if cc is None:
                cc = next((c for c in self.ud_node.children if c.deprel == 'punct' and c.lemma == ','), None)
            cord = next((k for k, v in conjs.items() if cc and cc.lemma in v), None)
            if not cord:  # coordination without conjunction/comma
                cord = 'and'
            if cc:
                self.umr_graph.find_and_remove_from_triples(cc.lemma, 2)

            conj = UMRNode(cord, self.umr_graph, already_added=True)
            arg_type = 'op' if cord != 'but-91' else 'ARG'

            if not self.extra_level:
                first_conj = self.parent
                second_conj = self
            else:
                first_conj = self.parent.parent if self.parent.parent else None
                second_conj = self.parent

            first_conj.parent, second_conj.parent = conj, conj

            if not self.ud_node.parent.parent.is_root():
                parent = self.find_by_ud_node(self.umr_graph, self.ud_node.parent.parent)
                conj.parent = parent
            else:
                root_var = conj.var_name
                parent = None

            for tup in self.umr_graph.triples:  # avoid clashes of abstract concepts and coordination
                if tup[2] == first_conj.var_name:
                    role, parent = tup[1], tup[0]
                    break

            self.umr_graph.triples = [tup for tup in self.umr_graph.triples if not (tup[0] == parent and tup[1] == role)]
            if conj.var_name != root_var:
                self.umr_graph.triples.append((parent, role, conj.var_name))
            self.umr_graph.track_conj[self.ud_node.parent] = conj.var_name

            for i, vc in enumerate([first_conj, second_conj], start=1):
                self.umr_graph.triples.append((conj.var_name, f'{arg_type}{i}', vc.var_name))
                vc.parent = conj

            if (self.ud_node.upos == 'NOUN' and role != 'other') or (self.ud_node.upos == 'ADJ' and self.ud_node.deprel in ['nsubj', 'obj', 'obl']):
                self.get_number_person('number')
                first_conj.already_added = True
                first_conj.already_added = True

            # attach additional conjuncts, if any
            for i, oc in enumerate((s for s in self.ud_node.siblings if s.deprel == 'conj'), start=3):
                oc_node = UMRNode.find_by_ud_node(self.umr_graph, oc)
                if not oc_node.already_added:
                    oc_node.role = f'op{i}'
                    oc_node.parent = conj
                    self.umr_graph.triples.append((conj.var_name, oc_node.role, oc_node.var_name))
                    oc_node.get_number_person('number')

        return root_var

    def copulas(self, copula=True):
        """
        Handle copular constructions by assigning the correct abstract roleset to the various configurations.
        If a set of relational terms is provided, it is used here to assign 'have-rel-role-92'.
        """
        replace_arg = None

        if self.ud_node.parent.feats['Case'] in ['Nom', 'Acc'] or (
                self.ud_node.parent.upos in ['NOUN', 'ADJ', 'PROPN', 'PRON'] and not self.ud_node.parent.feats['Case']):

            if self.ud_node.parent.upos == 'ADJ' or (self.ud_node.parent.upos == 'DET' and self.ud_node.parent.feats[
                'PronType'] != 'Prs'):  # TODO: double-check DET (anche ok 'tantus', ma hic sarebbe meglio identity...ma both Dem!!) + remove PRON and do smth with it
                concept = 'have-mod-91'
            elif self.ud_node.parent.upos == 'DET' and self.ud_node.parent.feats['PronType'] == 'Prs':
                concept = 'belong-91'
            elif self.ud_node.parent.upos in ['NOUN', 'PRON']:
                if self.ud_node.parent.upos == 'NOUN' and self.ud_node.parent.lemma in interpersonal:
                    concept = 'have-rel-role-92'
                    replace_arg = 'ARG3'
                else:
                    concept = 'identity-91'
            else:
                concept = 'MISSING'

        elif self.ud_node.parent.feats['NumType'] == 'Card':
            concept = 'have-quant-91'

        elif self.ud_node.parent.feats['Case'] == 'Dat':
            # double dative if ref_dative else dative of possession
            ref_dative = [s for s in self.ud_node.siblings if s.feats['Case'] == 'Dat' and s.deprel == 'obl:arg']
            concept = 'have-purpose-91' if ref_dative else 'belong-91'

        elif self.ud_node.parent.upos == 'VERB' and self.ud_node.parent.feats['VerbForm'] == 'Inf':
            concept = 'have-identity-91'

        elif self.ud_node.parent.upos in ['NOUN', 'PROPN'] and self.ud_node.parent.feats['Case'] == 'Gen':
            concept = 'belong-91'
        else:
            concept = 'MISSING'

        self.replace_with_abstract_roleset(concept, replace_arg, overt=copula)
        self.already_added = True

    def relative_clauses(self, rel_pron_node):
        """
        Process relative clauses, by handling:
        1. relative pronoun (rel_pron);
        2. predicate (node);
        3. referent of the whole relative clause (referent).
        """
        referent = None

        if rel_pron_node.ud_node == self.ud_node.parent:
            referent = rel_pron_node.var_name
            if rel_pron_node.ud_node.deprel == 'root':  # can't do anything about root-of, but I can at least save a root
                self.umr_graph.triples.append((None, 'root', referent))
        elif rel_pron_node.ud_node.parent == self.ud_node:
            if not self.extra_level:
                referent = self.parent.var_name if self.parent else None
            else:
                referent = self.parent.parent.var_name if self.parent.parent else None
            if rel_pron_node.ud_node.udeprel in ['nsubj', 'obj', 'obl']:
                self.umr_graph.find_and_remove_from_triples(rel_pron_node.var_name, 2)

        self.add_node(rel_pron_node.role, invert=True, def_parent=referent)
        rel_pron_node.check_needed = True

        for i, tup in enumerate(self.umr_graph.triples):
            if tup[1] == 'root-of':  # issues with head of relative being the root
                # look for other dependants
                if 'nsubj' in [d.deprel for d in self.ud_node.children]:
                    self.umr_graph.triples[i] = (tup[0], 'patient-of', tup[2])
                elif 'obj' in [d.deprel for d in self.ud_node.children]:
                    self.umr_graph.triples[i] = (tup[0], 'actor-of', tup[2])

    def adverbial_clauses(self):
        """
        Handle adverbial clauses.
        If a dictionary with disambiguated SCONJs is provided, it is used here to assign more fine-grained relations.
        """
        role = self.role
        sconj = next((c for c in self.ud_node.children if c.deprel == 'mark'), None)

        if sconj and sconj.lemma in advcl:
            constraint = advcl.get(sconj.lemma, {}).get('constraint')
            if constraint:
                feat, value = constraint.split('=')
                if sconj.parent.feats[feat] == value:
                    role = advcl.get(sconj.lemma, {}).get('type')

        if not self.extra_level:
            self.add_node(role)
        else:
            self.add_node(self.role, def_parent=self.parent.parent.var_name)
